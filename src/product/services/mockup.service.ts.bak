import { Injectable, BadRequestException, Logger } from '@nestjs/common';
import { PrismaService } from '../../prisma/prisma.service';
import { CreateMockupDto, MockupResponseDto, MockupGenre } from '../dto/create-mockup.dto';

@Injectable()
export class MockupService {
  private readonly logger = new Logger(MockupService.name);

  constructor(private readonly prisma: PrismaService) {}

  /**
   * Cr√©er un mockup avec genre
   */
  async createMockup(createMockupDto: CreateMockupDto): Promise<MockupResponseDto> {
    // Validation sp√©cifique pour les mockups
    if (createMockupDto.isReadyProduct !== false) {
      throw new BadRequestException('Les mockups doivent avoir isReadyProduct: false');
    }

    this.logger.log(`üé® Cr√©ation mockup: ${createMockupDto.name} - Genre: ${createMockupDto.genre || 'UNISEXE'}`);

    const mockup = await this.prisma.product.create({
      data: {
        name: createMockupDto.name,
        description: createMockupDto.description,
        price: createMockupDto.price,
        status: createMockupDto.status || 'draft',
        isReadyProduct: false, // Forcer √† false pour les mockups
        genre: createMockupDto.genre || MockupGenre.UNISEXE, // Valeur par d√©faut
        // Ajouter les relations si n√©cessaire
        categories: createMockupDto.categories ? {
          create: createMockupDto.categories.map(category => ({
            name: category
          }))
        } : undefined,
        sizes: createMockupDto.sizes ? {
          create: createMockupDto.sizes.map(size => ({
            sizeName: size
          }))
        } : undefined,
        colorVariations: createMockupDto.colorVariations ? {
          create: createMockupDto.colorVariations.map(color => ({
            name: color.name,
            colorCode: color.colorCode,
            images: color.images ? {
              create: color.images.map(image => ({
                url: image.url,
                view: image.view || 'Front'
              }))
            } : undefined
          }))
        } : undefined
      },
      include: {
        categories: true,
        colorVariations: {
          include: {
            images: true
          }
        },
        sizes: true
      }
    });
    
    this.logger.log(`‚úÖ Mockup cr√©√© avec succ√®s: ID ${mockup.id}, Genre: ${mockup.genre}`);
    
    return this.mapToResponseDto(mockup);
  }

  /**
   * Mettre √† jour un mockup avec genre
   */
  async updateMockup(id: number, updateMockupDto: Partial<CreateMockupDto>): Promise<MockupResponseDto> {
    this.logger.log(`üîÑ Mise √† jour mockup ID ${id} - Genre: ${updateMockupDto.genre}`);

    const mockup = await this.prisma.product.update({
      where: { id },
      data: {
        ...updateMockupDto,
        // Le genre peut √™tre mis √† jour
      },
      include: {
        categories: true,
        colorVariations: {
          include: {
            images: true
          }
        },
        sizes: true
      }
    });
    
    this.logger.log(`‚úÖ Mockup mis √† jour avec succ√®s: ID ${mockup.id}`);
    
    return this.mapToResponseDto(mockup);
  }

  /**
   * R√©cup√©rer les mockups par genre
   */
  async getMockupsByGenre(genre: MockupGenre): Promise<MockupResponseDto[]> {
    this.logger.log(`üîç R√©cup√©ration mockups par genre: ${genre}`);

    const mockups = await this.prisma.product.findMany({
      where: {
        genre,
        isReadyProduct: false,
        isDelete: false
      },
      include: {
        categories: true,
        colorVariations: {
          include: {
            images: true
          }
        },
        sizes: true
      }
    });
    
    this.logger.log(`üìä ${mockups.length} mockups trouv√©s pour le genre: ${genre}`);
    
    return mockups.map(mockup => this.mapToResponseDto(mockup));
  }

  /**
   * R√©cup√©rer tous les genres disponibles
   */
  async getAvailableMockupGenres(): Promise<string[]> {
    this.logger.log(`üîç R√©cup√©ration des genres disponibles`);

    const genres = await this.prisma.product.findMany({
      where: { 
        isReadyProduct: false,
        isDelete: false
      },
      select: { genre: true },
      distinct: ['genre']
    });
    
    const availableGenres = genres.map(g => g.genre).filter(Boolean);
    this.logger.log(`üìä Genres disponibles: ${availableGenres.join(', ')}`);
    
    return availableGenres;
  }

  /**
   * R√©cup√©rer tous les mockups avec filtre par genre
   */
  async getAllMockups(genre?: MockupGenre): Promise<MockupResponseDto[]> {
    this.logger.log(`üîç R√©cup√©ration tous les mockups${genre ? ` - Genre: ${genre}` : ''}`);

    let whereClause: any = { 
      isReadyProduct: false,
      isDelete: false
    };
    
    if (genre) {
      whereClause.genre = genre;
    }
    
    const mockups = await this.prisma.product.findMany({
      where: whereClause,
      include: {
        categories: true,
        colorVariations: {
          include: {
            images: true
          }
        },
        sizes: true
      }
    });
    
    this.logger.log(`üìä ${mockups.length} mockups trouv√©s`);
    
    return mockups.map(mockup => this.mapToResponseDto(mockup));
  }

  /**
   * Supprimer un mockup (soft delete)
   */
  async deleteMockup(id: number): Promise<void> {
    this.logger.log(`üóëÔ∏è Suppression mockup ID ${id}`);

    await this.prisma.product.update({
      where: { id },
      data: { isDelete: true }
    });
    
    this.logger.log(`‚úÖ Mockup supprim√© avec succ√®s: ID ${id}`);
  }

  /**
   * M√©thode utilitaire pour mapper vers la r√©ponse
   */
  private mapToResponseDto(mockup: any): MockupResponseDto {
    return {
      id: mockup.id,
      name: mockup.name,
      description: mockup.description,
      price: mockup.price,
      status: mockup.status,
      isReadyProduct: false,
      genre: mockup.genre,
      categories: mockup.categories || [],
      colorVariations: mockup.colorVariations || [],
      sizes: mockup.sizes || [],
      createdAt: mockup.createdAt,
      updatedAt: mockup.updatedAt
    };
  }
} 