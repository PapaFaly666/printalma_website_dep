// services/transformationService.ts
import { SelectedColor, SelectedSize } from './vendorProductService';

const API_BASE_URL = import.meta.env.VITE_API_URL || 'https://printalma-back-dep.onrender.com';

// =====================================================================
// Types
// =====================================================================

export interface Transformation {
  id: number;
  vendorId: number;
  baseProductId: number;
  designId: number;
  status: 'TRANSFORMATION';
  createdAt: string;
  updatedAt: string;
  position: {
    x: number;
    y: number;
    scale: number;
    rotation?: number;
  };
  previewImageUrl?: string;
  autoGeneratedName: string;
  positionId?: string; // ðŸ†• Ajout du positionId selon la documentation
}

export interface TransformationListResponse {
  success: boolean;
  transformations: Transformation[];
  pagination?: {
    total: number;
    page: number;
    limit: number;
    hasMore: boolean;
  };
}

export interface PublishTransformationPayload {
  name: string;
  description: string;
  price: number;
  stock: number;
  selectedColors: SelectedColor[];
  selectedSizes: SelectedSize[];
}

export interface PublishTransformationResponse {
  status: 'PUBLISHED';
  productId: number;
  message: string;
}

export interface CleanupResponse {
  success: boolean;
  removed: number;
  message?: string;
}

// ðŸ†• Types d'erreur selon la documentation
export interface ApiError {
  code: number;
  message: string;
  details?: any;
}

export class TransformationError extends Error {
  constructor(public code: number, message: string, public details?: any) {
    super(message);
    this.name = 'TransformationError';
  }
}

// =====================================================================
// Helpers (copiÃ©s depuis vendorProductService pour Ã©viter import circulaire)
// =====================================================================

function getAuthToken(): string | null {
  const tokenFromStorage = localStorage.getItem('authToken') || sessionStorage.getItem('authToken');
  if (tokenFromStorage) return tokenFromStorage;
  const cookies = document.cookie.split(';');
  for (const cookie of cookies) {
    const [name, value] = cookie.trim().split('=');
    if (['authToken', 'token', 'jwt'].includes(name)) return value;
  }
  return null;
}

function getRequestHeaders(): HeadersInit {
  const headers: HeadersInit = { 'Content-Type': 'application/json' };
  const token = getAuthToken();
  if (token) headers['Authorization'] = `Bearer ${token}`;
  return headers;
}

function getRequestOptions(method: string = 'GET', body?: any): RequestInit {
  const options: RequestInit = {
    method,
    headers: getRequestHeaders(),
    credentials: 'include',
  };
  if (body) options.body = JSON.stringify(body);
  return options;
}

// ðŸ†• Gestion des erreurs selon la documentation - Ã‰tape 6
function handleApiError(response: Response, errorData: any): TransformationError {
  const { status } = response;
  const message = errorData.message || `HTTP error! status: ${status}`;
  
  // Gestion des erreurs selon la documentation
  switch (status) {
    case 400:
      return new TransformationError(400, message, { 
        type: 'VALIDATION_ERROR',
        details: errorData.details || 'Mauvais payload'
      });
    case 403:
      return new TransformationError(403, message, { 
        type: 'PERMISSION_ERROR',
        details: 'Not owner - redirigez vers 403'
      });
    case 409:
      return new TransformationError(409, message, { 
        type: 'DUPLICATE_ERROR',
        details: 'Doublon - rechargez la liste'
      });
    case 404:
      return new TransformationError(404, message, { 
        type: 'NOT_FOUND_ERROR',
        details: 'Ressource introuvable'
      });
    case 500:
      return new TransformationError(500, message, { 
        type: 'SERVER_ERROR',
        details: 'Erreur serveur interne'
      });
    default:
      return new TransformationError(status, message, { 
        type: 'UNKNOWN_ERROR',
        details: errorData
      });
  }
}

// =====================================================================
// Service
// =====================================================================

class TransformationService {
  private baseUrl = `${API_BASE_URL}/vendor/transformations`;

  /**
   * ðŸ†• CrÃ©er une transformation (prototype) via POST /vendor/products
   * Selon la documentation - Ã‰tape 3
   */
  async createTransformation(payload: {
    baseProductId: number;
    designId: number;
    vendorName: string;
    vendorDescription: string;
    vendorPrice: number;
    vendorStock: number;
    selectedColors: SelectedColor[];
    selectedSizes: SelectedSize[];
    productStructure: {
      adminProduct: any;
      designApplication: {
        positioning: 'CENTER';
        scale: number;
      };
    };
    designPosition: {
      x: number;
      y: number;
      scale: number;
      rotation?: number;
    };
    bypassValidation?: boolean;
  }): Promise<{
    status: 'TRANSFORMATION';
    transformationId: number;
    positionId: string;
    message?: string;
  }> {
    try {
      const response = await fetch(`${API_BASE_URL}/vendor/products`, getRequestOptions('POST', payload));
      
      if (!response.ok) {
        const errorData = await response.json();
        throw handleApiError(response, errorData);
      }
      
      const result = await response.json();
      
      if (result.status !== 'TRANSFORMATION') {
        throw new TransformationError(500, 'RÃ©ponse inattendue du serveur', { result });
      }
      
      return result;
    } catch (error) {
      if (error instanceof TransformationError) {
        throw error;
      }
      throw new TransformationError(500, 'Erreur lors de la crÃ©ation de la transformation', error);
    }
  }

  /**
   * Liste des transformations (prototypes) - Ã‰tape 4
   * GET /vendor/transformations
   */
  async getTransformations(params?: {
    page?: number;
    limit?: number;
    baseProductId?: number;
    designId?: number;
  }): Promise<TransformationListResponse> {
    try {
      const searchParams = new URLSearchParams();
      if (params?.page) searchParams.append('page', params.page.toString());
      if (params?.limit) searchParams.append('limit', params.limit.toString());
      if (params?.baseProductId) searchParams.append('baseProductId', params.baseProductId.toString());
      if (params?.designId) searchParams.append('designId', params.designId.toString());
      
      const url = `${this.baseUrl}${searchParams.toString() ? '?' + searchParams.toString() : ''}`;
      const response = await fetch(url, getRequestOptions('GET'));
      
      if (!response.ok) {
        const errorData = await response.json();
        throw handleApiError(response, errorData);
      }
      
      return response.json();
    } catch (error) {
      if (error instanceof TransformationError) {
        throw error;
      }
      throw new TransformationError(500, 'Erreur lors de la rÃ©cupÃ©ration des transformations', error);
    }
  }

  /**
   * Publier (convertir) une transformation en produit rÃ©el - Ã‰tape 5
   * POST /vendor/transformations/:id/publish
   */
  async publishTransformation(id: number, payload: PublishTransformationPayload): Promise<PublishTransformationResponse> {
    try {
      const response = await fetch(`${this.baseUrl}/${id}/publish`, getRequestOptions('POST', payload));
      
      if (!response.ok) {
        const errorData = await response.json();
        throw handleApiError(response, errorData);
      }
      
      const result = await response.json();
      
      if (result.status !== 'PUBLISHED') {
        throw new TransformationError(500, 'RÃ©ponse inattendue du serveur', { result });
      }
      
      return result;
    } catch (error) {
      if (error instanceof TransformationError) {
        throw error;
      }
      throw new TransformationError(500, 'Erreur lors de la publication de la transformation', error);
    }
  }

  /**
   * Nettoyer les transformations (optionnel) - Ã‰tape 7
   * DELETE /vendor/transformations/cleanup?olderThanDays=14
   */
  async cleanupTransformations(olderThanDays: number = 14): Promise<CleanupResponse> {
    try {
      const endpoint = `${this.baseUrl}/cleanup?olderThanDays=${olderThanDays}`;
      const response = await fetch(endpoint, getRequestOptions('DELETE'));
      
      if (!response.ok) {
        const errorData = await response.json();
        throw handleApiError(response, errorData);
      }
      
      return response.json();
    } catch (error) {
      if (error instanceof TransformationError) {
        throw error;
      }
      throw new TransformationError(500, 'Erreur lors du nettoyage des transformations', error);
    }
  }

  /**
   * ðŸ†• Supprimer une transformation spÃ©cifique
   * DELETE /vendor/transformations/:id
   */
  async deleteTransformation(id: number): Promise<{ success: boolean; message: string }> {
    try {
      const response = await fetch(`${this.baseUrl}/${id}`, getRequestOptions('DELETE'));
      
      if (!response.ok) {
        const errorData = await response.json();
        throw handleApiError(response, errorData);
      }
      
      return response.json();
    } catch (error) {
      if (error instanceof TransformationError) {
        throw error;
      }
      throw new TransformationError(500, 'Erreur lors de la suppression de la transformation', error);
    }
  }

  /**
   * ðŸ†• Obtenir les dÃ©tails d'une transformation
   * GET /vendor/transformations/:id
   */
  async getTransformation(id: number): Promise<Transformation> {
    try {
      const response = await fetch(`${this.baseUrl}/${id}`, getRequestOptions('GET'));
      
      if (!response.ok) {
        const errorData = await response.json();
        throw handleApiError(response, errorData);
      }
      
      return response.json();
    } catch (error) {
      if (error instanceof TransformationError) {
        throw error;
      }
      throw new TransformationError(500, 'Erreur lors de la rÃ©cupÃ©ration de la transformation', error);
    }
  }

  /**
   * ðŸ†• Utilitaire pour vÃ©rifier si une transformation peut Ãªtre publiÃ©e
   */
  canPublishTransformation(transformation: Transformation): boolean {
    return transformation.status === 'TRANSFORMATION' &&
           transformation.position != null &&
           typeof transformation.designId === 'number' && transformation.designId > 0 &&
           typeof transformation.baseProductId === 'number' && transformation.baseProductId > 0;
  }

  /**
   * ðŸ†• Utilitaire pour formater les erreurs pour l'affichage
   */
  formatError(error: TransformationError): string {
    switch (error.code) {
      case 400:
        return `DonnÃ©es invalides: ${error.message}`;
      case 403:
        return `Permission refusÃ©e: ${error.message}`;
      case 409:
        return `Doublon dÃ©tectÃ©: ${error.message}`;
      case 404:
        return `Ressource introuvable: ${error.message}`;
      case 500:
        return `Erreur serveur: ${error.message}`;
      default:
        return error.message;
    }
  }
}

export const transformationService = new TransformationService();
export default transformationService; 