import { io } from 'socket.io-client';

class AnalyticsService {
  constructor() {
    this.baseURL = import.meta.env.VITE_API_URL || 'https://printalma-back-dep.onrender.com';
    this.cache = new Map();
    this.cacheTimeout = 5 * 60 * 1000; // 5 minutes
    this.socket = null;
    this.listeners = {};
  }

  // ==========================================
  // GESTION DU CACHE
  // ==========================================

  getCacheKey(endpoint, params = {}) {
    return `${endpoint}-${JSON.stringify(params)}`;
  }

  getCachedData(cacheKey) {
    if (this.cache.has(cacheKey)) {
      const cached = this.cache.get(cacheKey);
      if (Date.now() - cached.timestamp < this.cacheTimeout) {
        return cached.data;
      }
      this.cache.delete(cacheKey);
    }
    return null;
  }

  setCachedData(cacheKey, data) {
    this.cache.set(cacheKey, {
      data,
      timestamp: Date.now()
    });
  }

  clearCache() {
    this.cache.clear();
    console.log('üìä Cache analytics vid√©');
  }

  // ==========================================
  // M√âTHODES API
  // ==========================================

  async handleResponse(response) {
    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      
      switch (response.status) {
        case 401:
          throw new Error('Session expir√©e - Veuillez vous reconnecter');
        case 403:
          throw new Error('Acc√®s refus√© - Droits administrateur requis');
        case 404:
          throw new Error('Endpoint statistiques non trouv√©');
        case 500:
          throw new Error('Erreur serveur lors du calcul des statistiques');
        default:
          throw new Error(errorData.message || `Erreur ${response.status}`);
      }
    }
    
    const result = await response.json();
    return result.data || result;
  }

  async apiCall(endpoint, options = {}) {
    try {
      console.log(`üìä Analytics API Call: ${options.method || 'GET'} ${endpoint}`);
      
      const response = await fetch(`${this.baseURL}${endpoint}`, {
        credentials: 'include', // ‚≠ê ESSENTIEL pour l'auth admin
        headers: {
          'Content-Type': 'application/json',
          ...options.headers
        },
        ...options
      });

      const result = await this.handleResponse(response);
      console.log(`‚úÖ Analytics Success: ${endpoint}`);
      return result;
      
    } catch (error) {
      console.error(`‚ùå Analytics Error ${endpoint}:`, error);
      throw error;
    }
  }

  // ==========================================
  // 1. STATISTIQUES G√âN√âRALES (Dashboard Principal)
  // ==========================================

  /**
   * R√©cup√©rer les statistiques g√©n√©rales du dashboard
   * GET /orders/admin/statistics
   */
  async getStatistics(period = '30d', options = {}) {
    const params = { period, ...options };
    const cacheKey = this.getCacheKey('stats', params);
    
    // V√©rifier le cache
    const cached = this.getCachedData(cacheKey);
    if (cached) {
      console.log('üìä Stats r√©cup√©r√©es du cache');
      return cached;
    }

    const searchParams = new URLSearchParams();
    Object.entries(params).forEach(([key, value]) => {
      if (value) searchParams.append(key, value);
    });

    const data = await this.apiCall(`/orders/admin/statistics?${searchParams}`);
    
    // Mettre en cache
    this.setCachedData(cacheKey, data);
    
    return data;
  }

  // ==========================================
  // 2. STATISTIQUES DE REVENUS D√âTAILL√âES
  // ==========================================

  /**
   * R√©cup√©rer les statistiques de revenus d√©taill√©es
   * GET /orders/admin/revenue-stats
   */
  async getRevenueStats(options = {}) {
    const cacheKey = this.getCacheKey('revenue-stats', options);
    
    const cached = this.getCachedData(cacheKey);
    if (cached) {
      console.log('üí∞ Stats revenus r√©cup√©r√©es du cache');
      return cached;
    }

    const params = new URLSearchParams();
    Object.entries(options).forEach(([key, value]) => {
      if (value !== undefined && value !== null) {
        params.append(key, value);
      }
    });

    const data = await this.apiCall(`/orders/admin/revenue-stats?${params}`);
    
    this.setCachedData(cacheKey, data);
    return data;
  }

  // ==========================================
  // 3. STATISTIQUES CLIENTS
  // ==========================================

  /**
   * R√©cup√©rer les statistiques clients
   * GET /orders/admin/customer-stats
   */
  async getCustomerStats(options = {}) {
    const cacheKey = this.getCacheKey('customer-stats', options);
    
    const cached = this.getCachedData(cacheKey);
    if (cached) {
      console.log('üë• Stats clients r√©cup√©r√©es du cache');
      return cached;
    }

    const params = new URLSearchParams();
    Object.entries(options).forEach(([key, value]) => {
      if (value) params.append(key, value);
    });

    const data = await this.apiCall(`/orders/admin/customer-stats?${params}`);
    
    this.setCachedData(cacheKey, data);
    return data;
  }

  // ==========================================
  // 4. STATISTIQUES PRODUITS
  // ==========================================

  /**
   * R√©cup√©rer les statistiques produits
   * GET /orders/admin/product-stats
   */
  async getProductStats(options = {}) {
    const cacheKey = this.getCacheKey('product-stats', options);
    
    const cached = this.getCachedData(cacheKey);
    if (cached) {
      console.log('üì¶ Stats produits r√©cup√©r√©es du cache');
      return cached;
    }

    const params = new URLSearchParams();
    Object.entries(options).forEach(([key, value]) => {
      if (value) params.append(key, value);
    });

    const data = await this.apiCall(`/orders/admin/product-stats?${params}`);
    
    this.setCachedData(cacheKey, data);
    return data;
  }

  // ==========================================
  // 5. RAPPORTS PERSONNALIS√âS
  // ==========================================

  /**
   * G√©n√©rer un rapport personnalis√©
   * POST /orders/admin/custom-report
   */
  async generateCustomReport(config) {
    console.log('üìã G√©n√©ration rapport personnalis√©:', config);
    
    const data = await this.apiCall('/orders/admin/custom-report', {
      method: 'POST',
      body: JSON.stringify(config)
    });

    return data;
  }

  /**
   * T√©l√©charger un rapport g√©n√©r√©
   */
  async downloadReport(reportId, format = 'pdf') {
    const response = await fetch(`${this.baseURL}/downloads/reports/${reportId}.${format}`, {
      credentials: 'include'
    });

    if (!response.ok) {
      throw new Error(`Erreur t√©l√©chargement rapport: ${response.status}`);
    }

    return response.blob();
  }

  // ==========================================
  // 6. TEMPS R√âEL (WebSocket)
  // ==========================================

  /**
   * Connecter le WebSocket pour les statistiques temps r√©el
   */
  connectRealTime() {
    if (this.socket && this.socket.connected) {
      console.log('üìä WebSocket analytics d√©j√† connect√©');
      return this.socket;
    }

    console.log('üîå Connexion WebSocket analytics...');
    
    this.socket = io(`${this.baseURL}/analytics`, {
      withCredentials: true,
      transports: ['websocket', 'polling'],
      reconnection: true,
      reconnectionDelay: 1000,
      reconnectionAttempts: 5
    });

    this.setupRealtimeListeners();
    return this.socket;
  }

  setupRealtimeListeners() {
    if (!this.socket) return;

    this.socket.on('connect', () => {
      console.log('‚úÖ WebSocket analytics connect√©');
    });

    this.socket.on('disconnect', () => {
      console.log('‚ùå WebSocket analytics d√©connect√©');
    });

    // Nouvelles commandes en temps r√©el
    this.socket.on('orderCreated', (data) => {
      console.log('üÜï Nouvelle commande temps r√©el:', data);
      this.clearCache(); // Invalider le cache
      if (this.listeners.onNewOrder) {
        this.listeners.onNewOrder(data);
      }
    });

    // Mise √† jour des revenus
    this.socket.on('revenueUpdate', (data) => {
      console.log('üí∞ Revenus mis √† jour temps r√©el:', data);
      if (this.listeners.onRevenueUpdate) {
        this.listeners.onRevenueUpdate(data);
      }
    });

    // Visiteurs en ligne
    this.socket.on('visitorsUpdate', (data) => {
      console.log('üë• Visiteurs mis √† jour:', data);
      if (this.listeners.onVisitorsUpdate) {
        this.listeners.onVisitorsUpdate(data);
      }
    });

    // Changement de statut commande
    this.socket.on('orderStatusChanged', (data) => {
      console.log('üìù Statut commande chang√©:', data);
      this.clearCache(); // Invalider le cache
      if (this.listeners.onOrderStatusChanged) {
        this.listeners.onOrderStatusChanged(data);
      }
    });
  }

  /**
   * Enregistrer des callbacks pour les √©v√©nements temps r√©el
   */
  onNewOrder(callback) {
    this.listeners.onNewOrder = callback;
  }

  onRevenueUpdate(callback) {
    this.listeners.onRevenueUpdate = callback;
  }

  onVisitorsUpdate(callback) {
    this.listeners.onVisitorsUpdate = callback;
  }

  onOrderStatusChanged(callback) {
    this.listeners.onOrderStatusChanged = callback;
  }

  /**
   * D√©connecter le WebSocket
   */
  disconnectRealTime() {
    if (this.socket) {
      this.socket.disconnect();
      this.socket = null;
      console.log('üîå WebSocket analytics d√©connect√©');
    }
  }

  // ==========================================
  // M√âTHODES UTILITAIRES
  // ==========================================

  /**
   * Formater les montants en euros
   */
  formatCurrency(amount, currency = 'EUR') {
    return new Intl.NumberFormat('fr-FR', {
      style: 'currency',
      currency: currency
    }).format(amount || 0);
  }

  /**
   * Formater les nombres avec s√©parateurs
   */
  formatNumber(number) {
    return new Intl.NumberFormat('fr-FR').format(number || 0);
  }

  /**
   * Formater les dates
   */
  formatDate(date, options = {}) {
    const defaultOptions = {
      year: 'numeric',
      month: 'short',
      day: 'numeric'
    };
    
    return new Date(date).toLocaleDateString('fr-FR', { ...defaultOptions, ...options });
  }

  /**
   * Calculer le pourcentage de changement
   */
  calculateGrowthRate(current, previous) {
    if (!previous || previous === 0) return 0;
    return ((current - previous) / previous) * 100;
  }

  /**
   * Obtenir l'ic√¥ne de tendance
   */
  getTrendIcon(growthRate) {
    if (growthRate > 0) return 'üìà';
    if (growthRate < 0) return 'üìâ';
    return '‚û°Ô∏è';
  }

  /**
   * Obtenir la classe CSS de tendance
   */
  getTrendClass(growthRate) {
    if (growthRate > 0) return 'positive';
    if (growthRate < 0) return 'negative';
    return 'neutral';
  }

  // ==========================================
  // TESTS ET DEBUG
  // ==========================================

  /**
   * Tester la connectivit√© aux statistiques
   */
  async testConnection() {
    try {
      const stats = await this.getStatistics('7d');
      console.log('‚úÖ Test analytics r√©ussi:', stats);
      return true;
    } catch (error) {
      console.error('‚ùå Test analytics √©chou√©:', error);
      return false;
    }
  }

  /**
   * Obtenir des informations de debug
   */
  getDebugInfo() {
    return {
      baseURL: this.baseURL,
      cacheSize: this.cache.size,
      socketConnected: this.socket?.connected || false,
      listeners: Object.keys(this.listeners)
    };
  }
}

// Export du service singleton
export const analyticsService = new AnalyticsService();
export default analyticsService; 