import { useState, useCallback } from 'react';
import { ProductFormData, ProductFormErrors, ColorVariation, ProductImage, ImageView } from '../types/product';
import { ProductService, CreateProductPayload, ProductFile } from '../services/productService';
import { updateProductStocks } from '../services/stockService';
import { useCategories } from '../contexts/CategoryContext';
import { toast } from 'sonner';
import { normalizeSizes, validateSizes } from '../utils/productNormalization';

const initialFormData: ProductFormData = {
  name: '',
  price: 0,
  suggestedPrice: undefined,
  stock: 0,
  status: 'draft',
  description: '',
  categoryId: undefined, // ID de la cat√©gorie s√©lectionn√©e
  categories: [], // Garde pour compatibilit√© mais utilise categoryId maintenant
  designs: [],
  colorVariations: [],
  sizes: [], // Added missing sizes field
  colors: [], // Couleurs disponibles (ex: Noir, Blanc)
  stockBySizeColor: {}, // Stock par taille et couleur
  genre: 'UNISEXE' // ‚Üê NOUVEAU: Ajout du champ genre
};

export const useProductForm = () => {
  const [formData, setFormData] = useState<ProductFormData>(initialFormData);
  const [errors, setErrors] = useState<ProductFormErrors>({});
  const [loading, setLoading] = useState(false);
  
  // Utiliser le contexte des cat√©gories pour la conversion nom -> ID
  const { categories: availableCategories } = useCategories();

  const updateFormData = useCallback(<K extends keyof ProductFormData>(
    field: K,
    value: ProductFormData[K]
  ) => {
    // Debug pour categories
    if (field === 'categories') {
      console.log('üîç [DEBUG useProductForm updateFormData] Updating categories field with:', value);
    }

    setFormData(prev => {
      const updated = {
        ...prev,
        [field]: value
      };

      // Debug pour categories
      if (field === 'categories') {
        console.log('üîç [DEBUG useProductForm updateFormData] New formData will be:', updated);
      }

      return updated;
    });

    // Clear error when field is updated
    if (errors[field as keyof ProductFormErrors]) {
      setErrors(prev => ({
        ...prev,
        [field]: undefined
      }));
    }
  }, [errors]);

  const addCategory = useCallback((category: string) => {
    if (!formData.categories.includes(category)) {
      updateFormData('categories', [...formData.categories, category]);
    }
  }, [formData.categories, updateFormData]);

  const removeCategory = useCallback((category: string) => {
    updateFormData('categories', formData.categories.filter(c => c !== category));
  }, [formData.categories, updateFormData]);

  const addDesign = useCallback((design: string) => {
    if (!formData.designs.includes(design)) {
      updateFormData('designs', [...formData.designs, design]);
    }
  }, [formData.designs, updateFormData]);

  const removeDesign = useCallback((design: string) => {
    updateFormData('designs', formData.designs.filter(d => d !== design));
  }, [formData.designs, updateFormData]);

  const addColorVariation = useCallback(() => {
    const newColor: ColorVariation = {
      id: Date.now().toString(),
      name: '',
      colorCode: '#ffffff',
      images: []
    };
    updateFormData('colorVariations', [...formData.colorVariations, newColor]);
    return newColor.id;
  }, [formData.colorVariations, updateFormData]);

  const updateColorVariation = useCallback((colorId: string, updates: Partial<ColorVariation>) => {
    const updatedColors = formData.colorVariations.map(color =>
      color.id === colorId ? { ...color, ...updates } : color
    );
    updateFormData('colorVariations', updatedColors);
  }, [formData.colorVariations, updateFormData]);

  const removeColorVariation = useCallback((colorId: string) => {
    updateFormData('colorVariations', formData.colorVariations.filter(c => c.id !== colorId));
  }, [formData.colorVariations, updateFormData]);

  const addImageToColor = useCallback((colorId: string, file: File) => {
    const newImage: ProductImage = {
      id: Date.now().toString(),
      url: URL.createObjectURL(file),
      file,
      view: 'Front',
      delimitations: []
    };

    const updatedColors = formData.colorVariations.map(color =>
      color.id === colorId 
        ? { ...color, images: [...color.images, newImage] }
        : color
    );
    updateFormData('colorVariations', updatedColors);
    return newImage.id;
  }, [formData.colorVariations, updateFormData]);

  const updateImage = useCallback((colorId: string, imageId: string, updates: Partial<ProductImage>) => {
    const updatedColors = formData.colorVariations.map(color => {
      if (color.id === colorId) {
        const updatedImages = color.images.map(image =>
          image.id === imageId ? { ...image, ...updates } : image
        );
        return { ...color, images: updatedImages };
      }
      return color;
    });
    updateFormData('colorVariations', updatedColors);
  }, [formData.colorVariations, updateFormData]);

  // Validation du formulaire
  const validateForm = useCallback((): boolean => {
    const newErrors: Record<string, string> = {};

    if (!formData.name.trim()) {
      newErrors.name = 'Le nom du produit est requis';
    }

    if (!formData.description.trim()) {
      newErrors.description = 'La description est requise';
    }

    if (formData.price <= 0) {
      newErrors.price = 'Le prix doit √™tre sup√©rieur √† 0';
    }

    if (formData.stock < 0) {
      newErrors.stock = 'Le stock ne peut pas √™tre n√©gatif';
    }

    // ‚úÖ Accepter soit categoryId (ancien syst√®me) soit categories (nouveau syst√®me)
    // Note: categoryId peut √™tre undefined ici car il est extrait dans handleSubmit AVANT l'appel √† submitForm
    const hasCategoryId = formData.categoryId !== undefined && formData.categoryId !== null;
    const hasCategories = formData.categories && formData.categories.length > 0;

    console.log('üîç [DEBUG VALIDATION] Cat√©gories:', {
      categoryId: formData.categoryId,
      hasCategoryId,
      categories: formData.categories,
      categoriesLength: formData.categories?.length,
      hasCategories
    });

    // ‚úÖ CORRECTION: Accepter si AU MOINS UN des deux syst√®mes a des donn√©es
    if (!hasCategoryId && !hasCategories) {
      newErrors.categories = 'S√©lectionnez une cat√©gorie';
      console.log('‚ùå [DEBUG VALIDATION] Validation √©chou√©e: aucune cat√©gorie');
    } else {
      console.log('‚úÖ [DEBUG VALIDATION] Validation pass√©e -', hasCategoryId ? 'via categoryId' : 'via categories array');
    }

    if (formData.colorVariations.length === 0) {
      newErrors.colorVariations = 'Ajoutez au moins une variation de couleur';
    } else {
      formData.colorVariations.forEach((color, index) => {
        if (!color.name.trim()) {
          newErrors[`colorVariations.${index}.name`] = 'Le nom de la couleur est requis';
        }
        if (!color.colorCode) {
          newErrors[`colorVariations.${index}.colorCode`] = 'Le code couleur est requis';
        }
        if (color.images.length === 0) {
          newErrors[`colorVariations.${index}.images`] = 'Ajoutez au moins une image pour cette couleur';
        }
      });
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  }, [formData]);

  const submitForm = useCallback(async () => {
    if (!validateForm()) {
      toast.error('Veuillez corriger les erreurs dans le formulaire');
      return false;
    }

    setLoading(true);
    try {
      // Envoyer categoryId au lieu du tableau categories
      console.log(`üîç [DEBUG] Cat√©gorie s√©lectionn√©e (ID):`, formData.categoryId);

      // ‚úÖ G√âN√âRATION DU CHAMP categories (OBLIGATOIRE selon selection.md)
      // Le backend attend un array de strings (noms de cat√©gories)
      const categoriesArray: string[] = [];

      // Construire le array de noms depuis formData.categories (format "Category > SubCategory > Variation")
      if (formData.categories && Array.isArray(formData.categories) && formData.categories.length > 0) {
        // Si categories existe et contient le format UI complet, extraire seulement le nom de la cat√©gorie principale
        const categoryString = formData.categories[0];
        const parts = categoryString.split(' > ').map(p => p.trim());

        // Prendre le premier niveau comme cat√©gorie principale
        if (parts.length > 0 && parts[0]) {
          categoriesArray.push(parts[0]);
          console.log('‚úÖ [DEBUG] Cat√©gorie extraite depuis UI format:', parts[0]);
        }
      } else if (formData.categoryId && availableCategories && availableCategories.length > 0) {
        // Fallback: Trouver le nom de la cat√©gorie depuis categoryId
        const foundCategory = availableCategories.find(cat => cat.id === formData.categoryId);
        if (foundCategory && foundCategory.name) {
          categoriesArray.push(foundCategory.name);
          console.log('‚úÖ [DEBUG] Cat√©gorie extraite depuis categoryId:', foundCategory.name);
        }
      }

      // Validation finale du champ categories
      if (categoriesArray.length === 0) {
        toast.error('‚ùå Erreur: Au moins une cat√©gorie est requise');
        setLoading(false);
        return false;
      }

      console.log('üìã [DEBUG] Champ categories g√©n√©r√© (array de strings):', categoriesArray);

      // Transformer les donn√©es du formulaire pour l'API selon la nouvelle documentation
      const apiPayload: CreateProductPayload = {
        name: formData.name,
        description: formData.description,
        price: formData.price,
        suggestedPrice: formData.suggestedPrice, // ‚úÖ AJOUT√â: Champ prix sugg√©r√©
        stock: formData.stock,
        status: formData.status,
        // ‚úÖ OBLIGATOIRE: Array de noms de cat√©gories (strings) selon selection.md
        categories: categoriesArray,
        // ‚úÖ CORRECTION: Envoyer les 3 niveaux de cat√©gories selon cate.md
        categoryId: formData.categoryId, // Cat√©gorie principale (level 0)
        subCategoryId: (formData as any).subCategoryId || null, // Sous-cat√©gorie (level 1)
        variationId: (formData as any).variationId || null, // Variation (level 2)
        sizes: normalizeSizes(formData.sizes || []), // Normalized array of strings
        genre: formData.genre || 'UNISEXE', // ‚Üê NOUVEAU: Ajout du champ genre
        isReadyProduct: false, // ‚Üê NOUVEAU: Force isReadyProduct: false pour les mockups
        colorVariations: formData.colorVariations.map(color => ({
          name: color.name,
          colorCode: color.colorCode,
          // ‚úÖ Envoyer stockBySize comme objet (format backend mockup)
          stockBySize: color.stock || {},
          images: color.images.map(image => ({
            fileId: image.id,
            view: image.view,
            delimitations: (image.delimitations || []).map(delim => ({
              x: delim.x,
              y: delim.y,
              width: delim.width,
              height: delim.height,
              rotation: delim.rotation || 0,
              name: delim.name
            }))
          }))
        }))
      };

      // Pr√©parer les fichiers
      const files: File[] = [];
      formData.colorVariations.forEach(color => {
        color.images.forEach(image => {
          if (image.file) {
            files.push(image.file);
          }
        });
      });

      console.log('üìã Donn√©es pr√©par√©es pour l\'API:', {
        payload: apiPayload,
        filesCount: files.length
      });
      console.log('üîç [DEBUG] Genre dans formData:', formData.genre);
      console.log('üîç [DEBUG] Genre dans apiPayload:', apiPayload.genre);
      console.log('üîç [DEBUG] Prix sugg√©r√©:', formData.suggestedPrice);
      console.log('üîç [DEBUG] Prix sugg√©r√© sera envoy√©:', apiPayload.suggestedPrice);
      // ‚úÖ NOUVEAU: V√©rifier les 3 niveaux de cat√©gories
      console.log('üè∑Ô∏è [CATEGORIES] Hi√©rarchie envoy√©e:', {
        categoryId: apiPayload.categoryId,
        subCategoryId: apiPayload.subCategoryId,
        variationId: apiPayload.variationId
      });
      console.log('üîç [DEBUG] Stock par variation (format objet stockBySize):', apiPayload.colorVariations?.map(c => ({
        name: c.name,
        stockBySize: c.stockBySize
      })));

      // Appeler l'API avec le nouveau format
      const result = await ProductService.createProduct(apiPayload, files);

      if (result.success) {
        const createdProduct = result.data;
        console.log('‚úÖ [DEBUG] Produit cr√©√©:', createdProduct);

        // ‚úÖ IMPORTANT: Enregistrer les stocks en base de donn√©es
        if (createdProduct?.id && formData.colorVariations.length > 0) {
          try {
            // Pr√©parer les stocks pour l'API stockService
            const stocksToSave: { colorId: number; sizeName: string; stock: number }[] = [];

            formData.colorVariations.forEach((color, colorIndex) => {
              // Trouver l'ID de la couleur cr√©√©e dans la r√©ponse du backend
              const createdColor = createdProduct.colorVariations?.[colorIndex];

              if (createdColor?.id && color.stock) {
                // Pour chaque taille ayant du stock
                Object.entries(color.stock).forEach(([sizeName, stockQty]) => {
                  if (stockQty > 0) {
                    stocksToSave.push({
                      colorId: createdColor.id,
                      sizeName,
                      stock: stockQty
                    });
                  }
                });
              }
            });

            if (stocksToSave.length > 0) {
              console.log('üì¶ [DEBUG] Enregistrement des stocks:', stocksToSave);
              await updateProductStocks(createdProduct.id, stocksToSave);
              console.log('‚úÖ [DEBUG] Stocks enregistr√©s avec succ√®s en base de donn√©es');
            }
          } catch (stockError) {
            console.error('‚ùå [ERROR] Erreur lors de l\'enregistrement des stocks:', stockError);
            toast.warning('Produit cr√©√© mais erreur lors de l\'enregistrement des stocks');
          }
        }

        toast.success(result.message || 'Produit cr√©√© avec succ√®s !');
        setFormData(initialFormData);
        return true;
      } else {
        const errorMessage = ProductService.handleApiError(new Error(result.error || 'Erreur inconnue'));
        toast.error(errorMessage);
        return false;
      }
    } catch (error) {
      console.error('Error submitting product:', error);
      const errorMessage = ProductService.handleApiError(error);
      toast.error(errorMessage);
      return false;
    } finally {
      setLoading(false);
    }
  }, [formData, validateForm, availableCategories]);

  const resetForm = useCallback(() => {
    setFormData(initialFormData);
    setErrors({});
  }, []);

  return {
    formData,
    errors,
    loading,
    updateFormData,
    addCategory,
    removeCategory,
    addDesign,
    removeDesign,
    addColorVariation,
    updateColorVariation,
    removeColorVariation,
    addImageToColor,
    updateImage,
    validateForm,
    submitForm,
    resetForm
  };
}; 