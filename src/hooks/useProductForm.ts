import { useState, useCallback } from 'react';
import { ProductFormData, ProductFormErrors, ColorVariation, ProductImage, ImageView } from '../types/product';
import { ProductService, CreateProductPayload, ProductFile } from '../services/productService';
import { updateProductStocks } from '../services/stockService';
import { useCategories } from '../contexts/CategoryContext';
import { toast } from 'sonner';
import { normalizeSizes, validateSizes } from '../utils/productNormalization';

const initialFormData: ProductFormData = {
  name: '',
  price: 0,
  suggestedPrice: undefined,
  stock: 0,
  status: 'published',
  description: '',
  categoryId: undefined, // ID de la cat√©gorie s√©lectionn√©e
  categories: [], // Garde pour compatibilit√© mais utilise categoryId maintenant
  designs: [],
  colorVariations: [],
  sizes: [], // Added missing sizes field
  colors: [], // Couleurs disponibles (ex: Noir, Blanc)
  stockBySizeColor: {}, // Stock par taille et couleur
  genre: 'UNISEXE' // ‚Üê NOUVEAU: Ajout du champ genre
};

export const useProductForm = () => {
  const [formData, setFormData] = useState<ProductFormData>(initialFormData);
  const [errors, setErrors] = useState<ProductFormErrors>({});
  const [loading, setLoading] = useState(false);
  
  // Utiliser le contexte des cat√©gories pour la conversion nom -> ID
  const { categories: availableCategories } = useCategories();

  const updateFormData = useCallback(<K extends keyof ProductFormData>(
    field: K,
    value: ProductFormData[K]
  ) => {
    // Debug pour categories
    if (field === 'categories') {
      console.log('üîç [DEBUG useProductForm updateFormData] Updating categories field with:', value);
    }

    setFormData(prev => {
      const updated = {
        ...prev,
        [field]: value
      };

      // Debug pour categories
      if (field === 'categories') {
        console.log('üîç [DEBUG useProductForm updateFormData] New formData will be:', updated);
      }

      return updated;
    });

    // Clear error when field is updated
    if (errors[field as keyof ProductFormErrors]) {
      setErrors(prev => ({
        ...prev,
        [field]: undefined
      }));
    }
  }, [errors]);

  const addCategory = useCallback((category: string) => {
    if (!formData.categories.includes(category)) {
      updateFormData('categories', [...formData.categories, category]);
    }
  }, [formData.categories, updateFormData]);

  const removeCategory = useCallback((category: string) => {
    updateFormData('categories', formData.categories.filter(c => c !== category));
  }, [formData.categories, updateFormData]);

  const addDesign = useCallback((design: string) => {
    if (!formData.designs.includes(design)) {
      updateFormData('designs', [...formData.designs, design]);
    }
  }, [formData.designs, updateFormData]);

  const removeDesign = useCallback((design: string) => {
    updateFormData('designs', formData.designs.filter(d => d !== design));
  }, [formData.designs, updateFormData]);

  const addColorVariation = useCallback(() => {
    const newColor: ColorVariation = {
      id: Date.now().toString(),
      name: '',
      colorCode: '#ffffff',
      images: []
    };
    updateFormData('colorVariations', [...formData.colorVariations, newColor]);
    return newColor.id;
  }, [formData.colorVariations, updateFormData]);

  const updateColorVariation = useCallback((colorId: string, updates: Partial<ColorVariation>) => {
    const updatedColors = formData.colorVariations.map(color =>
      color.id === colorId ? { ...color, ...updates } : color
    );
    updateFormData('colorVariations', updatedColors);
  }, [formData.colorVariations, updateFormData]);

  const removeColorVariation = useCallback((colorId: string) => {
    updateFormData('colorVariations', formData.colorVariations.filter(c => c.id !== colorId));
  }, [formData.colorVariations, updateFormData]);

  const addImageToColor = useCallback((colorId: string, file: File) => {
    const newImage: ProductImage = {
      id: Date.now().toString(),
      url: URL.createObjectURL(file),
      file,
      view: 'Front',
      delimitations: []
    };

    const updatedColors = formData.colorVariations.map(color =>
      color.id === colorId 
        ? { ...color, images: [...color.images, newImage] }
        : color
    );
    updateFormData('colorVariations', updatedColors);
    return newImage.id;
  }, [formData.colorVariations, updateFormData]);

  const updateImage = useCallback((colorId: string, imageId: string, updates: Partial<ProductImage>) => {
    const updatedColors = formData.colorVariations.map(color => {
      if (color.id === colorId) {
        const updatedImages = color.images.map(image =>
          image.id === imageId ? { ...image, ...updates } : image
        );
        return { ...color, images: updatedImages };
      }
      return color;
    });
    updateFormData('colorVariations', updatedColors);
  }, [formData.colorVariations, updateFormData]);

  // Validation du formulaire
  const validateForm = useCallback((): boolean => {
    const newErrors: Record<string, string> = {};

    if (!formData.name.trim()) {
      newErrors.name = 'Le nom du produit est requis';
    }

    if (!formData.description.trim()) {
      newErrors.description = 'La description est requise';
    }

    if (formData.price <= 0) {
      newErrors.price = 'Le prix doit √™tre sup√©rieur √† 0';
    }

  
    // ‚úÖ Accepter soit categoryId (ancien syst√®me) soit categories (nouveau syst√®me)
    // Note: categoryId peut √™tre undefined ici car il est extrait dans handleSubmit AVANT l'appel √† submitForm
    const hasCategoryId = formData.categoryId !== undefined && formData.categoryId !== null;
    const hasCategories = formData.categories && formData.categories.length > 0;

    console.log('üîç [DEBUG VALIDATION] Cat√©gories:', {
      categoryId: formData.categoryId,
      hasCategoryId,
      categories: formData.categories,
      categoriesLength: formData.categories?.length,
      hasCategories
    });

    // ‚úÖ CORRECTION: Accepter si AU MOINS UN des deux syst√®mes a des donn√©es
    if (!hasCategoryId && !hasCategories) {
      newErrors.categories = 'S√©lectionnez une cat√©gorie';
      console.log('‚ùå [DEBUG VALIDATION] Validation √©chou√©e: aucune cat√©gorie');
    } else {
      console.log('‚úÖ [DEBUG VALIDATION] Validation pass√©e -', hasCategoryId ? 'via categoryId' : 'via categories array');
    }

    if (formData.colorVariations.length === 0) {
      newErrors.colorVariations = 'Ajoutez au moins une variation de couleur';
    } else {
      formData.colorVariations.forEach((color, index) => {
        if (!color.name.trim()) {
          newErrors[`colorVariations.${index}.name`] = 'Le nom de la couleur est requis';
        }
        if (!color.colorCode) {
          newErrors[`colorVariations.${index}.colorCode`] = 'Le code couleur est requis';
        }
        if (color.images.length === 0) {
          newErrors[`colorVariations.${index}.images`] = 'Ajoutez au moins une image pour cette couleur';
        }
      });
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  }, [formData]);

  const submitForm = useCallback(async () => {
    if (!validateForm()) {
      toast.error('Veuillez corriger les erreurs dans le formulaire');
      return false;
    }

    setLoading(true);
    try {
      console.log('üöÄ [SUBMIT FORM] D√©but de la soumission du produit...');
      console.log('üîç [DEBUG] FormData re√ßu:', {
        name: formData.name,
        categoryId: formData.categoryId,
        subCategoryId: (formData as any).subCategoryId,
        variationId: (formData as any).variationId,
        categories: formData.categories
      });

      // üîß CORRECTION CRITIQUE : Utiliser les IDs corrects depuis formData
      // Les IDs devraient d√©j√† √™tre extraits et ajout√©s dans ProductFormMain.handleSubmit()
      const categoryId = formData.categoryId ? parseInt(formData.categoryId.toString()) : null;
      const subCategoryId = (formData as any).subCategoryId ? parseInt((formData as any).subCategoryId.toString()) : null;
      const variationId = (formData as any).variationId ? parseInt((formData as any).variationId.toString()) : null;

      console.log('üîß [NORMALIZATION] IDs pars√©s:', {
        categoryId,
        subCategoryId,
        variationId,
        types: {
          categoryId: typeof categoryId,
          subCategoryId: typeof subCategoryId,
          variationId: typeof variationId
        }
      });

      // Validation des IDs obligatoires
      if (!categoryId) {
        toast.error('‚ùå Cat√©gorie requise pour la cr√©ation du produit');
        setLoading(false);
        return false;
      }

      // ‚úÖ CONSTRUCTION DU PAYLOAD CORRECT selon la documentation API
      const apiPayload: CreateProductPayload = {
        name: formData.name,
        description: formData.description,
        price: formData.price,
        suggestedPrice: formData.suggestedPrice,
        stock: formData.stock,
        status: formData.status,

        // ‚úÖ FORMAT CORRECT : IDs pour les cat√©gories
        categoryId: categoryId.toString(), // ‚Üê string requis pour compatibilit√©
        subcategoryId: subCategoryId, // ‚Üê nombre entier requis (note: subcategoryId sans 'C' majuscule)

        // ‚úÖ VARIATIONS avec structure correcte
        variations: formData.colorVariations.map(color => ({
          variationId: variationId, // ‚Üê ID de la variation (peut √™tre null)
          value: color.name, // ‚Üê Nom de la couleur comme valeur
          colorCode: color.colorCode,
          price: formData.price, // ‚Üê Prix par d√©faut
          stock: color.stock && typeof color.stock === 'object'
            ? Object.values(color.stock).reduce((sum: number, qty: any) => sum + (qty || 0), 0)
            : 0,
          images: color.images.map(image => ({
            fileId: image.id,
            view: image.view,
            delimitations: (image.delimitations || []).map(delim => ({
              x: delim.x,
              y: delim.y,
              width: delim.width,
              height: delim.height,
              rotation: delim.rotation || 0,
              name: delim.name
            }))
          }))
        })),

        // Autres champs
        sizes: normalizeSizes(formData.sizes || []),
        genre: formData.genre || 'UNISEXE',
        isReadyProduct: false // Pour les mockups admin
      };

      // Supprimer les anciens champs qui ne sont plus n√©cessaires
      // Note: ces champs n'existent plus dans le nouvel interface CreateProductPayload

      console.log('üéØ [SUBMIT FORM] Payload final pour cr√©ation:', {
        name: apiPayload.name,
        categoryId: apiPayload.categoryId,
        subcategoryId: apiPayload.subcategoryId,
        hasVariations: apiPayload.variations?.length > 0,
        variationsCount: apiPayload.variations?.length || 0,
        genre: apiPayload.genre
      });

      console.log('üè∑Ô∏è [CATEGORIES] Hi√©rarchie CORRIG√âE envoy√©e:', {
        categoryId: apiPayload.categoryId,     // ‚úÖ Nombre entier
        subcategoryId: apiPayload.subcategoryId, // ‚úÖ Nombre entier
        variationId: variationId                // ‚úÖ Nombre entier (si applicable)
      });

      // Pr√©parer les fichiers
      const files: File[] = [];
      formData.colorVariations.forEach(color => {
        color.images.forEach(image => {
          if (image.file) {
            files.push(image.file);
          }
        });
      });

      console.log('üìã [SUBMIT FORM] Donn√©es pr√©par√©es pour l\'API:', {
        payloadName: apiPayload.name,
        filesCount: files.length,
        variationsCount: apiPayload.variations?.length || 0
      });

      // Appeler l'API avec le format corrig√©
      const result = await ProductService.createProduct(apiPayload, files);

      if (result.success) {
        const createdProduct = result.data;
        console.log('‚úÖ [SUBMIT FORM] Produit cr√©√© avec succ√®s:', createdProduct);

        // V√©rifier que les cat√©gories sont correctement li√©es
        console.log('üè∑Ô∏è [SUBMIT FORM] V√©rification des cat√©gories dans le produit cr√©√©:', {
          productId: createdProduct.id,
          categoryId: createdProduct.categoryId,
          subcategoryId: createdProduct.subcategoryId,
          categoryName: createdProduct.category?.name,
          subcategoryName: createdProduct.subcategory?.name
        });

        toast.success('Produit cr√©√© avec succ√®s !');
        setFormData(initialFormData);
        return true;
      } else {
        console.error('‚ùå [SUBMIT FORM] Erreur lors de la cr√©ation:', result.error);
        const errorMessage = ProductService.handleApiError(new Error(result.error || 'Erreur inconnue'));
        toast.error(errorMessage);
        return false;
      }
    } catch (error) {
      console.error('Error submitting product:', error);
      const errorMessage = ProductService.handleApiError(error);
      toast.error(errorMessage);
      return false;
    } finally {
      setLoading(false);
    }
  }, [formData, validateForm, availableCategories]);

  const resetForm = useCallback(() => {
    setFormData(initialFormData);
    setErrors({});
  }, []);

  return {
    formData,
    errors,
    loading,
    updateFormData,
    addCategory,
    removeCategory,
    addDesign,
    removeDesign,
    addColorVariation,
    updateColorVariation,
    removeColorVariation,
    addImageToColor,
    updateImage,
    validateForm,
    submitForm,
    resetForm
  };
}; 