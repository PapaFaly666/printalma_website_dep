import { useState, useEffect, useRef, useCallback } from 'react';
import { designTransformsStorage, DesignTransform } from '../services/designTransformsStorage';
import { loadDesignTransforms, saveDesignTransforms } from '../services/designTransformsAPI';

export interface UseDesignTransformsOptions {
  vendorProductId: number;
  designUrl: string;
  enabled?: boolean;
  autoSaveDelay?: number; // D√©lai avant auto-sauvegarde (d√©faut: 3000ms)
}

export function useDesignTransformsOptimized({
  vendorProductId,
  designUrl,
  enabled = true,
  autoSaveDelay = 3000
}: UseDesignTransformsOptions) {
  const [transforms, setTransforms] = useState<Record<string, DesignTransform>>({});
  const [isLoading, setIsLoading] = useState(true);
  const [isDirty, setIsDirty] = useState(false);
  const [isSaving, setIsSaving] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  const autoSaveTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const lastSaveRef = useRef<number>(0);
  const isInitializedRef = useRef(false);

  // üö® VALIDATION DES PARAM√àTRES
  const isValidParams = useCallback(() => {
    const valid = vendorProductId && vendorProductId > 0 && designUrl && designUrl.trim() !== '';
    console.log('üîç Validation des param√®tres:', {
      vendorProductId,
      designUrl: designUrl ? designUrl.substring(0, 50) + '...' : 'undefined',
      valid,
      enabled
    });
    return valid;
  }, [vendorProductId, designUrl, enabled]);

  /**
   * Chargement initial depuis localStorage puis backend
   */
  const loadInitialData = useCallback(async () => {
    console.log('üîÑ === D√âBUT CHARGEMENT INITIAL ===');
    console.log('√âtat initial:', {
      enabled,
      isInitialized: isInitializedRef.current,
      vendorProductId,
      designUrl: designUrl ? designUrl.substring(0, 50) + '...' : 'undefined'
    });

    // üö® V√âRIFICATION PR√âLIMINAIRE
    if (!enabled) {
      console.log('‚ùå Hook d√©sactiv√©, arr√™t du chargement');
      setIsLoading(false);
      return;
    }

    if (isInitializedRef.current) {
      console.log('‚ùå D√©j√† initialis√©, arr√™t du chargement');
      return;
    }

    if (!isValidParams()) {
      console.log('‚ùå Param√®tres invalides, arr√™t du chargement');
      setError('Param√®tres invalides pour le chargement des transformations');
      setIsLoading(false);
      isInitializedRef.current = true;
      return;
    }
    
    setIsLoading(true);
    setError(null);
    
    try {
      console.log('üì± Tentative chargement localStorage...');
      
      // 1. Charger depuis localStorage imm√©diatement (UX fluide)
      const localState = designTransformsStorage.loadFromLocal(vendorProductId, designUrl);
      if (localState && Object.keys(localState.transforms).length > 0) {
        setTransforms(localState.transforms);
        setIsDirty(localState.isDirty);
        console.log('‚úÖ Transforms charg√©s depuis localStorage:', Object.keys(localState.transforms).length, 'items');
      } else {
        console.log('‚ÑπÔ∏è Aucun transform en localStorage');
      }
      
      // 2. Charger depuis backend en arri√®re-plan (avec timeout)
      console.log('‚òÅÔ∏è Tentative chargement backend...');
      try {
        const backendPromise = loadDesignTransforms(vendorProductId, designUrl);
        const timeoutPromise = new Promise((_, reject) => 
          setTimeout(() => reject(new Error('Backend timeout')), 5000)
        );
        
        const backendData = await Promise.race([backendPromise, timeoutPromise]);
        
        if (backendData && (backendData as any).transforms) {
          const backendTransforms = (backendData as any).transforms;
          const backendTime = (backendData as any).lastModified || 0;
          
          // Comparer les timestamps pour d√©cider quelle version utiliser
          const localTime = localState?.lastModified || 0;
          
          console.log('üìä Comparaison versions:', { backendTime, localTime });
          
          if (backendTime > localTime) {
            // Backend plus r√©cent, l'utiliser
            setTransforms(backendTransforms);
            setIsDirty(false);
            designTransformsStorage.saveToLocal(vendorProductId, designUrl, backendTransforms);
            designTransformsStorage.markAsSaved(vendorProductId, designUrl);
            console.log('‚úÖ Transforms mis √† jour depuis backend');
          } else if (localState?.isDirty) {
            // Local plus r√©cent et dirty, programmer une sauvegarde
            scheduleAutoSave();
            console.log('üì§ Transforms locaux plus r√©cents, sauvegarde programm√©e');
          }
        } else {
          console.log('‚ÑπÔ∏è Pas de donn√©es backend valides');
        }
      } catch (backendError: any) {
        // Gestion gracieuse de l'erreur 403 et autres erreurs backend
        if (backendError?.response?.status === 403) {
          console.log('‚ÑπÔ∏è Erreur 403 - Mode conception admin product, utilisation localStorage');
        } else if (backendError.message === 'Backend timeout') {
          console.log('‚è∞ Timeout backend - Utilisation localStorage uniquement');
        } else {
          console.warn('‚ö†Ô∏è Backend indisponible, utilisation localStorage:', backendError.message);
        }
        // Continuer avec localStorage, le backend sera synchronis√© plus tard
      }
      
    } catch (error: any) {
      console.error('‚ùå Erreur chargement initial:', error);
      setError('Erreur lors du chargement des transformations');
    } finally {
      console.log('üèÅ Fin chargement initial - setIsLoading(false)');
      setIsLoading(false);
      isInitializedRef.current = true;
    }
  }, [vendorProductId, designUrl, enabled, isValidParams]);

  /**
   * Sauvegarde automatique diff√©r√©e
   */
  const scheduleAutoSave = useCallback(() => {
    if (autoSaveTimeoutRef.current) {
      clearTimeout(autoSaveTimeoutRef.current);
    }
    
    autoSaveTimeoutRef.current = setTimeout(async () => {
      if (!isDirty) return;
      
      console.log('üîÑ D√©clenchement auto-sauvegarde...');
      setIsSaving(true);
      designTransformsStorage.markAsLoading(vendorProductId, designUrl, true);
      
      try {
        await saveDesignTransforms({
          productId: vendorProductId,
          designUrl,
          transforms,
          lastModified: Date.now()
        });
        
        designTransformsStorage.markAsSaved(vendorProductId, designUrl);
        setIsDirty(false);
        lastSaveRef.current = Date.now();
        console.log('‚úÖ Auto-sauvegarde r√©ussie');
        
        // √âmettre √©v√©nement pour notifications
        window.dispatchEvent(new CustomEvent('transform:saved'));
        
      } catch (error: any) {
        console.error('‚ùå Erreur auto-sauvegarde:', error);
        // Garder en localStorage pour retry plus tard
        
        // Ne pas consid√©rer 403 comme une vraie erreur
        if (error?.response?.status !== 403) {
          setError('Erreur de sauvegarde automatique');
          window.dispatchEvent(new CustomEvent('transform:error'));
        }
      } finally {
        setIsSaving(false);
        designTransformsStorage.markAsLoading(vendorProductId, designUrl, false);
      }
    }, autoSaveDelay);
  }, [vendorProductId, designUrl, transforms, isDirty, autoSaveDelay]);

  /**
   * Mettre √† jour un transform (sauvegarde localStorage imm√©diate)
   */
  const updateTransform = useCallback((index: string, transform: DesignTransform) => {
    if (!isValidParams()) {
      console.warn('‚ö†Ô∏è Tentative updateTransform avec param√®tres invalides');
      return;
    }

    const newTransforms = {
      ...transforms,
      [index]: transform
    };
    
    setTransforms(newTransforms);
    setIsDirty(true);
    
    // Sauvegarde imm√©diate en localStorage
    designTransformsStorage.saveToLocal(vendorProductId, designUrl, newTransforms);
    
    // Programmer auto-sauvegarde backend
    scheduleAutoSave();
    
    console.log(`üé® Transform ${index} mis √† jour localement`);
  }, [transforms, vendorProductId, designUrl, scheduleAutoSave, isValidParams]);

  /**
   * Sauvegarde manuelle (validation vendeur)
   */
  const saveManually = useCallback(async () => {
    if (!isDirty || isSaving || !isValidParams()) return;
    
    console.log('üíæ Sauvegarde manuelle d√©marr√©e...');
    setIsSaving(true);
    setError(null);
    designTransformsStorage.markAsLoading(vendorProductId, designUrl, true);
    
    try {
      await saveDesignTransforms({
        productId: vendorProductId,
        designUrl,
        transforms,
        lastModified: Date.now()
      });
      
      designTransformsStorage.markAsSaved(vendorProductId, designUrl);
      setIsDirty(false);
      lastSaveRef.current = Date.now();
      
      // Annuler l'auto-sauvegarde programm√©e
      if (autoSaveTimeoutRef.current) {
        clearTimeout(autoSaveTimeoutRef.current);
        autoSaveTimeoutRef.current = null;
      }
      
      console.log('‚úÖ Sauvegarde manuelle r√©ussie');
      window.dispatchEvent(new CustomEvent('transform:saved'));
      return true;
      
    } catch (error: any) {
      console.error('‚ùå Erreur sauvegarde manuelle:', error);
      
      // Gestion sp√©ciale de l'erreur 403
      if (error?.response?.status === 403) {
        setError('Mode conception - Sauvegarde locale uniquement');
      } else {
        setError('Erreur lors de la sauvegarde');
        window.dispatchEvent(new CustomEvent('transform:error'));
      }
      return false;
    } finally {
      setIsSaving(false);
      designTransformsStorage.markAsLoading(vendorProductId, designUrl, false);
    }
  }, [vendorProductId, designUrl, transforms, isDirty, isSaving, isValidParams]);

  /**
   * R√©initialiser aux valeurs backend
   */
  const resetToBackend = useCallback(async () => {
    if (!isValidParams()) return;
    
    setIsLoading(true);
    try {
      const backendData = await loadDesignTransforms(vendorProductId, designUrl);
      if (backendData) {
        setTransforms((backendData as any).transforms || {});
        setIsDirty(false);
        designTransformsStorage.saveToLocal(vendorProductId, designUrl, (backendData as any).transforms || {});
        designTransformsStorage.markAsSaved(vendorProductId, designUrl);
        
        // Annuler auto-sauvegarde en cours
        if (autoSaveTimeoutRef.current) {
          clearTimeout(autoSaveTimeoutRef.current);
          autoSaveTimeoutRef.current = null;
        }
      }
    } catch (error: any) {
      if (error?.response?.status === 403) {
        setError('Mode conception - Reset non disponible');
      } else {
        setError('Erreur lors du reset');
      }
    } finally {
      setIsLoading(false);
    }
  }, [vendorProductId, designUrl, isValidParams]);

  /**
   * Obtenir un transform sp√©cifique
   */
  const getTransform = useCallback((index: string): DesignTransform | undefined => {
    return transforms[index];
  }, [transforms]);

  // üö® EFFET DE CHARGEMENT INITIAL AVEC TIMEOUT DE S√âCURIT√â
  useEffect(() => {
    console.log('üîÑ useEffect loadInitialData d√©clench√©');
    
    // Timeout de s√©curit√© pour √©viter le chargement infini
    const safetyTimeout = setTimeout(() => {
      if (isLoading && !isInitializedRef.current) {
        console.log('üö® TIMEOUT DE S√âCURIT√â - Arr√™t forc√© du chargement');
        setIsLoading(false);
        setError('Timeout: Chargement trop long');
        isInitializedRef.current = true;
      }
    }, 10000); // 10 secondes max

    loadInitialData().finally(() => {
      clearTimeout(safetyTimeout);
    });

    return () => {
      clearTimeout(safetyTimeout);
    };
  }, [loadInitialData]);

  // Cleanup
  useEffect(() => {
    return () => {
      if (autoSaveTimeoutRef.current) {
        clearTimeout(autoSaveTimeoutRef.current);
      }
    };
  }, []);

  // üö® LOG D'√âTAT POUR DEBUG
  useEffect(() => {
    console.log('üìä √âtat du hook:', {
      isLoading,
      isInitialized: isInitializedRef.current,
      transformsCount: Object.keys(transforms).length,
      isDirty,
      isSaving,
      error,
      vendorProductId,
      designUrlLength: designUrl?.length || 0
    });
  }, [isLoading, transforms, isDirty, isSaving, error, vendorProductId, designUrl]);

  return {
    // √âtat
    transforms,
    isLoading,
    isDirty,
    isSaving,
    error,
    
    // Actions
    updateTransform,
    saveManually,
    resetToBackend,
    getTransform,
    
    // M√©tadonn√©es
    lastSave: lastSaveRef.current,
    hasUnsavedChanges: isDirty,
    isInitialized: isInitializedRef.current
  };
} 