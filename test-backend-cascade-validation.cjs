#!/usr/bin/env node

/**
 * üß™ TEST BACKEND CASCADE VALIDATION
 * 
 * Script pour tester le syst√®me de validation cascade apr√®s impl√©mentation backend
 * Usage: node test-backend-cascade-validation.cjs
 */

const API_BASE_URL = process.env.API_URL || 'http://localhost:3004';

// Couleurs pour les logs
const colors = {
    red: '\x1b[31m',
    green: '\x1b[32m',
    yellow: '\x1b[33m',
    blue: '\x1b[34m',
    magenta: '\x1b[35m',
    cyan: '\x1b[36m',
    white: '\x1b[37m',
    reset: '\x1b[0m'
};

function log(color, message) {
    console.log(`${colors[color]}${message}${colors.reset}`);
}

function logSection(title) {
    console.log('\n' + '='.repeat(60));
    log('cyan', `üß™ ${title}`);
    console.log('='.repeat(60));
}

function logTest(testName) {
    log('blue', `\nüîç Test: ${testName}`);
}

function logSuccess(message) {
    log('green', `‚úÖ ${message}`);
}

function logError(message) {
    log('red', `‚ùå ${message}`);
}

function logWarning(message) {
    log('yellow', `‚ö†Ô∏è ${message}`);
}

function logInfo(message) {
    log('white', `‚ÑπÔ∏è ${message}`);
}

// Helper pour les requ√™tes HTTP
async function makeRequest(method, endpoint, data = null, headers = {}) {
    const url = `${API_BASE_URL}${endpoint}`;
    
    const options = {
        method,
        headers: {
            'Content-Type': 'application/json',
            'credentials': 'include',
            ...headers
        }
    };
    
    if (data) {
        options.body = JSON.stringify(data);
    }
    
    try {
        const response = await fetch(url, options);
        const result = await response.json();
        
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${result.message || result.error || 'Unknown error'}`);
        }
        
        return result;
    } catch (error) {
        logError(`Request failed: ${method} ${endpoint}`);
        logError(`Error: ${error.message}`);
        throw error;
    }
}

// Variables globales pour les tests
let testData = {
    designId: null,
    productIds: [],
    vendorId: null
};

async function testDatabaseStructure() {
    logSection('V√âRIFICATION STRUCTURE BASE DE DONN√âES');
    
    logTest('V√©rification table design_product_links');
    try {
        // Test si la table existe en essayant une requ√™te
        const result = await makeRequest('GET', '/api/admin/designs/1/products');
        logSuccess('Table design_product_links existe et accessible');
    } catch (error) {
        logError('Table design_product_links manquante ou inaccessible');
        logError('Ex√©cuter: CREATE TABLE design_product_links...');
        return false;
    }
    
    return true;
}

async function testCreateDesign() {
    logSection('CR√âATION DESIGN DE TEST');
    
    logTest('Cr√©ation d\'un nouveau design');
    try {
        const designData = {
            name: `Test Design ${Date.now()}`,
            description: 'Design pour test cascade validation',
            imageUrl: 'https://example.com/test-design.png',
            price: 500 // 5.00‚Ç¨
        };
        
        const result = await makeRequest('POST', '/api/designs', designData);
        testData.designId = result.designId || result.id;
        
        logSuccess(`Design cr√©√© avec ID: ${testData.designId}`);
        logInfo(`Design non valid√© par d√©faut: isValidated = false`);
        
        return true;
    } catch (error) {
        logError('Impossible de cr√©er un design de test');
        return false;
    }
}

async function testCreateProductsWithDesign() {
    logSection('CR√âATION PRODUITS AVEC DESIGN');
    
    const testCases = [
        {
            name: 'Produit Auto-Publication',
            workflow: 'AUTO-PUBLISH',
            postValidationAction: 'AUTO_PUBLISH'
        },
        {
            name: 'Produit Publication Manuelle',
            workflow: 'MANUAL-PUBLISH',
            postValidationAction: 'TO_DRAFT'
        }
    ];
    
    for (const testCase of testCases) {
        logTest(`Cr√©ation: ${testCase.name}`);
        
        try {
            const productData = {
                baseProductId: 1, // Assuming base product exists
                designId: testData.designId,
                vendorName: `Test ${testCase.name}`,
                vendorDescription: `Description ${testCase.name}`,
                vendorPrice: 2000, // 20.00‚Ç¨
                workflow: testCase.workflow,
                postValidationAction: testCase.postValidationAction,
                selectedColors: [{ id: 1, name: 'Blanc', colorCode: '#FFFFFF' }],
                selectedSizes: [{ id: 1, sizeName: 'M' }],
                forcedStatus: 'PENDING'
            };
            
            const result = await makeRequest('POST', '/api/vendor/products', productData);
            const productId = result.productId;
            testData.productIds.push(productId);
            
            logSuccess(`Produit cr√©√© avec ID: ${productId}`);
            logInfo(`Workflow: ${testCase.workflow}`);
            logInfo(`Status initial: PENDING`);
            logInfo(`isValidated: false (design pas encore valid√©)`);
            
            // V√©rifier le lien design-produit
            const linkCheck = await makeRequest('GET', `/api/vendor/products/${productId}/design`);
            if (linkCheck.hasLinkedDesign && linkCheck.design.id == testData.designId) {
                logSuccess(`Lien design-produit cr√©√© correctement`);
            } else {
                logError(`Lien design-produit manquant`);
            }
            
        } catch (error) {
            logError(`√âchec cr√©ation ${testCase.name}`);
        }
    }
    
    return testData.productIds.length > 0;
}

async function testProductStatusBeforeValidation() {
    logSection('V√âRIFICATION STATUS AVANT VALIDATION');
    
    for (const productId of testData.productIds) {
        logTest(`V√©rification produit ${productId}`);
        
        try {
            const result = await makeRequest('GET', `/api/vendor/products/${productId}`);
            const product = result.data || result;
            
            logInfo(`Status: ${product.status}`);
            logInfo(`isValidated: ${product.isValidated}`);
            logInfo(`readyToPublish: ${product.readyToPublish}`);
            logInfo(`pendingAutoPublish: ${product.pendingAutoPublish}`);
            logInfo(`workflow: ${product.workflow}`);
            
            // V√©rifications attendues
            if (product.status === 'PENDING' && !product.isValidated) {
                logSuccess('Status correct avant validation');
            } else {
                logWarning('Status inattendu avant validation');
            }
            
        } catch (error) {
            logError(`Impossible de v√©rifier le produit ${productId}`);
        }
    }
}

async function testDesignValidation() {
    logSection('VALIDATION DESIGN PAR ADMIN');
    
    logTest('Validation du design par l\'admin');
    
    try {
        const result = await makeRequest('POST', `/api/admin/designs/${testData.designId}/validate`);
        
        logSuccess('Design valid√© par l\'admin');
        logInfo(`Produits mis √† jour: ${result.updatedProducts}`);
        
        if (result.cascadeActions && result.cascadeActions.length > 0) {
            logSuccess('Actions cascade ex√©cut√©es:');
            result.cascadeActions.forEach(action => {
                logInfo(`  Produit ${action.productId}: ${action.oldStatus} ‚Üí ${action.newStatus}`);
                logInfo(`  Workflow: ${action.workflow}`);
            });
        }
        
        return true;
    } catch (error) {
        logError('√âchec validation design');
        return false;
    }
}

async function testProductStatusAfterValidation() {
    logSection('V√âRIFICATION STATUS APR√àS VALIDATION');
    
    for (const productId of testData.productIds) {
        logTest(`V√©rification produit ${productId} apr√®s validation`);
        
        try {
            const result = await makeRequest('GET', `/api/vendor/products/${productId}`);
            const product = result.data || result;
            
            logInfo(`Status: ${product.status}`);
            logInfo(`isValidated: ${product.isValidated}`);
            logInfo(`readyToPublish: ${product.readyToPublish}`);
            logInfo(`pendingAutoPublish: ${product.pendingAutoPublish}`);
            logInfo(`workflow: ${product.workflow}`);
            
            // V√©rifications selon le workflow
            if (product.isValidated) {
                logSuccess('‚úÖ isValidated = true (SUCC√àS!)');
                
                if (product.workflow === 'AUTO-PUBLISH') {
                    if (product.status === 'PUBLISHED') {
                        logSuccess('‚úÖ Auto-publication r√©ussie');
                    } else {
                        logError('‚ùå Auto-publication √©chou√©e');
                    }
                } else if (product.workflow === 'MANUAL-PUBLISH') {
                    if (product.status === 'DRAFT' && product.readyToPublish) {
                        logSuccess('‚úÖ Pr√™t pour publication manuelle');
                    } else {
                        logError('‚ùå Status incorrect pour publication manuelle');
                    }
                }
            } else {
                logError('‚ùå isValidated = false (√âCHEC!)');
            }
            
        } catch (error) {
            logError(`Impossible de v√©rifier le produit ${productId}`);
        }
    }
}

async function testManualPublication() {
    logSection('TEST PUBLICATION MANUELLE');
    
    // Trouver un produit pr√™t √† publier manuellement
    for (const productId of testData.productIds) {
        try {
            const result = await makeRequest('GET', `/api/vendor/products/${productId}`);
            const product = result.data || result;
            
            if (product.workflow === 'MANUAL-PUBLISH' && product.readyToPublish) {
                logTest(`Publication manuelle du produit ${productId}`);
                
                const publishResult = await makeRequest('PUT', `/api/vendor/products/${productId}/publish`);
                
                if (publishResult.success && publishResult.newStatus === 'PUBLISHED') {
                    logSuccess('‚úÖ Publication manuelle r√©ussie');
                } else {
                    logError('‚ùå Publication manuelle √©chou√©e');
                }
                
                break;
            }
        } catch (error) {
            logError(`Erreur test publication manuelle: ${error.message}`);
        }
    }
}

async function testDesignProductLinks() {
    logSection('V√âRIFICATION LIENS DESIGN-PRODUITS');
    
    logTest('R√©cup√©ration des produits li√©s au design');
    
    try {
        const result = await makeRequest('GET', `/api/admin/designs/${testData.designId}/products`);
        
        logSuccess(`${result.totalProducts} produit(s) li√©(s) au design`);
        
        result.linkedProducts.forEach(product => {
            logInfo(`Produit ${product.id}: ${product.vendor_name}`);
            logInfo(`  Status: ${product.status}`);
            logInfo(`  Workflow: ${product.workflow}`);
            logInfo(`  isValidated: ${product.isValidated}`);
        });
        
        if (result.totalProducts === testData.productIds.length) {
            logSuccess('‚úÖ Tous les produits sont correctement li√©s');
        } else {
            logError('‚ùå Nombre de produits li√©s incorrect');
        }
        
    } catch (error) {
        logError('Impossible de r√©cup√©rer les liens design-produits');
    }
}

async function testCleanup() {
    logSection('NETTOYAGE DES DONN√âES DE TEST');
    
    // Supprimer les produits de test
    for (const productId of testData.productIds) {
        try {
            await makeRequest('DELETE', `/api/vendor/products/${productId}`);
            logSuccess(`Produit ${productId} supprim√©`);
        } catch (error) {
            logWarning(`Impossible de supprimer le produit ${productId}`);
        }
    }
    
    // Supprimer le design de test
    if (testData.designId) {
        try {
            await makeRequest('DELETE', `/api/designs/${testData.designId}`);
            logSuccess(`Design ${testData.designId} supprim√©`);
        } catch (error) {
            logWarning(`Impossible de supprimer le design ${testData.designId}`);
        }
    }
}

async function runAllTests() {
    log('magenta', 'üöÄ D√âBUT DES TESTS CASCADE VALIDATION BACKEND');
    log('white', `API URL: ${API_BASE_URL}`);
    
    try {
        // Tests s√©quentiels
        const structureOk = await testDatabaseStructure();
        if (!structureOk) {
            logError('Structure base de donn√©es incorrecte - Arr√™t des tests');
            return;
        }
        
        const designCreated = await testCreateDesign();
        if (!designCreated) {
            logError('Impossible de cr√©er un design - Arr√™t des tests');
            return;
        }
        
        const productsCreated = await testCreateProductsWithDesign();
        if (!productsCreated) {
            logError('Impossible de cr√©er des produits - Arr√™t des tests');
            return;
        }
        
        await testProductStatusBeforeValidation();
        
        const validationOk = await testDesignValidation();
        if (!validationOk) {
            logError('Validation design √©chou√©e - Arr√™t des tests');
            return;
        }
        
        // Attendre un peu pour la propagation
        log('yellow', '‚è≥ Attente 2 secondes pour la propagation...');
        await new Promise(resolve => setTimeout(resolve, 2000));
        
        await testProductStatusAfterValidation();
        await testManualPublication();
        await testDesignProductLinks();
        
        logSection('R√âSUM√â DES TESTS');
        logSuccess('üéâ Tests cascade validation termin√©s');
        logInfo('V√©rifiez les logs ci-dessus pour les d√©tails');
        
        // Nettoyage
        await testCleanup();
        
    } catch (error) {
        logError(`Erreur g√©n√©rale: ${error.message}`);
    }
}

// Ex√©cution des tests
if (require.main === module) {
    runAllTests().catch(error => {
        logError(`Erreur fatale: ${error.message}`);
        process.exit(1);
    });
}

module.exports = {
    runAllTests,
    testData
}; 