#!/usr/bin/env node

/**
 * üß™ TEST INT√âGRATION V2 : Validation Architecture Admin Pr√©serv√©e
 * 
 * Ce script teste:
 * 1. Authentification JWT + cookies fallback
 * 2. Endpoints API V2
 * 3. Structure de donn√©es conforme
 * 4. Images non vides
 * 5. Transformation legacy ‚Üí V2
 */

// Utiliser fetch natif de Node.js 18+
// const fetch = require('node-fetch'); // Plus besoin

// Configuration
const API_BASE_URL = process.env.VITE_API_URL || 'http://localhost:3004';
const VENDOR_API_BASE = `${API_BASE_URL}/api/vendor`;

// Couleurs pour les logs
const colors = {
  reset: '\x1b[0m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m'
};

function log(level, message, data = null) {
  const timestamp = new Date().toISOString();
  const levelColors = {
    'INFO': colors.cyan,
    'SUCCESS': colors.green,
    'WARNING': colors.yellow,
    'ERROR': colors.red,
    'DEBUG': colors.magenta
  };
  
  console.log(`${levelColors[level] || ''}[${timestamp}] ${level}: ${message}${colors.reset}`);
  if (data) {
    console.log(JSON.stringify(data, null, 2));
  }
}

// Extraction du token d'authentification (simulation browser)
function getAuthToken() {
  // Simuler les diff√©rentes sources de token
  const sources = [
    process.env.AUTH_TOKEN,
    process.env.JWT_TOKEN,
    process.env.VENDOR_TOKEN
  ];
  
  for (const token of sources) {
    if (token) {
      log('INFO', `Token trouv√© dans les variables d'environnement`);
      return token;
    }
  }
  
  log('WARNING', 'Aucun token trouv√© - Test en mode public');
  return null;
}

// Headers de requ√™te avec authentification hybride
function getRequestHeaders(includeAuth = true) {
  const headers = {
    'Content-Type': 'application/json',
    'User-Agent': 'PrintAlma-V2-Test/1.0'
  };
  
  if (includeAuth) {
    const token = getAuthToken();
    if (token) {
      headers['Authorization'] = `Bearer ${token}`;
      log('INFO', 'üîë Authentification par token JWT');
    } else {
      log('INFO', 'üîë Mode test sans authentification');
    }
  }
  
  return headers;
}

// Test 1: Health Check API
async function testHealthCheck() {
  log('INFO', 'üè• === TEST 1: HEALTH CHECK V2 ===');
  
  try {
    const response = await fetch(`${VENDOR_API_BASE}/health`, {
      method: 'GET',
      headers: getRequestHeaders(false) // Health check sans auth
    });
    
    log('INFO', `Status: ${response.status}`);
    
    if (response.ok) {
      const data = await response.json();
      
      log('SUCCESS', 'Health check r√©ussi');
      log('DEBUG', 'Response data:', {
        status: data.status,
        architecture: data.architecture,
        features: data.features?.length || 0,
        services: Object.keys(data.services || {})
      });
      
      // V√©rification architecture V2
      if (data.architecture === 'v2_admin_preserved') {
        log('SUCCESS', '‚úÖ Architecture V2 confirm√©e');
      } else {
        log('WARNING', `Architecture inattendue: ${data.architecture}`);
      }
      
      return true;
    } else {
      const errorText = await response.text();
      log('ERROR', `Health check √©chou√©: ${response.status}`);
      log('DEBUG', 'Error details:', errorText);
      return false;
    }
  } catch (error) {
    log('ERROR', `Erreur r√©seau health check: ${error.message}`);
    return false;
  }
}

// Test 2: Authentification
async function testAuthentication() {
  log('INFO', 'üîë === TEST 2: AUTHENTIFICATION V2 ===');
  
  const token = getAuthToken();
  if (!token) {
    log('WARNING', 'Pas de token - Skip test authentification');
    return null;
  }
  
  try {
    // Test avec token JWT
    const response = await fetch(`${VENDOR_API_BASE}/stats`, {
      method: 'GET',
      headers: getRequestHeaders(true)
    });
    
    log('INFO', `Status avec token: ${response.status}`);
    
    if (response.status === 401) {
      log('ERROR', '‚ùå Token JWT rejet√©');
      return false;
    }
    
    if (response.ok) {
      const data = await response.json();
      log('SUCCESS', '‚úÖ Authentification JWT r√©ussie');
      log('DEBUG', 'Stats response:', {
        success: data.success,
        architecture: data.data?.architecture
      });
      return true;
    }
    
    // Test fallback cookies
    log('INFO', 'Test fallback cookies...');
    const responseCookies = await fetch(`${VENDOR_API_BASE}/stats`, {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
        'Cookie': `authToken=${token}; jwt=${token}`
      }
    });
    
    if (responseCookies.ok) {
      log('SUCCESS', '‚úÖ Authentification par cookies r√©ussie');
      return true;
    }
    
    log('ERROR', '‚ùå Authentification √©chou√©e (JWT + cookies)');
    return false;
    
  } catch (error) {
    log('ERROR', `Erreur test authentification: ${error.message}`);
    return false;
  }
}

// Test 3: Structure API V2
async function testApiV2Structure() {
  log('INFO', 'üìã === TEST 3: STRUCTURE API V2 ===');
  
  try {
    const response = await fetch(`${VENDOR_API_BASE}/products?limit=5`, {
      method: 'GET',
      headers: getRequestHeaders(true)
    });
    
    log('INFO', `Status: ${response.status}`);
    
    if (!response.ok) {
      if (response.status === 401) {
        log('WARNING', 'Endpoint prot√©g√© - Skip test structure');
        return null;
      }
      
      const errorText = await response.text();
      log('ERROR', `API error: ${response.status}`);
      log('DEBUG', 'Error details:', errorText);
      return false;
    }
    
    const data = await response.json();
    
    // Validation structure V2
    const checks = {
      hasSuccess: data.hasOwnProperty('success'),
      hasData: data.hasOwnProperty('data') || data.hasOwnProperty('products'),
      hasPagination: data.pagination && typeof data.pagination === 'object',
      hasHealthMetrics: data.healthMetrics && typeof data.healthMetrics === 'object'
    };
    
    log('DEBUG', 'Structure checks:', checks);
    
    // Validation des produits
    const products = data.data?.products || data.products || [];
    log('INFO', `Nombre de produits: ${products.length}`);
    
    if (products.length > 0) {
      const firstProduct = products[0];
      
      const productChecks = {
        hasId: firstProduct.hasOwnProperty('id'),
        hasVendorName: firstProduct.hasOwnProperty('vendorName'),
        hasAdminProduct: firstProduct.hasOwnProperty('adminProduct'),
        hasDesignApplication: firstProduct.hasOwnProperty('designApplication'),
        hasImages: firstProduct.hasOwnProperty('images'),
        hasVendor: firstProduct.hasOwnProperty('vendor')
      };
      
      log('DEBUG', 'Product structure checks:', productChecks);
      
      // V√©rification architecture V2 sp√©cifique
      if (firstProduct.adminProduct?.colorVariations) {
        log('SUCCESS', '‚úÖ Structure admin pr√©serv√©e d√©tect√©e');
        
        const colorVariations = firstProduct.adminProduct.colorVariations;
        log('INFO', `Variations de couleur: ${colorVariations.length}`);
        
        // V√©rifier les images non vides
        let hasValidImages = false;
        for (const variation of colorVariations) {
          for (const image of variation.images || []) {
            if (image.url && image.url.trim() && image.url !== '') {
              hasValidImages = true;
              break;
            }
          }
          if (hasValidImages) break;
        }
        
        if (hasValidImages) {
          log('SUCCESS', '‚úÖ Images valides trouv√©es (non vides)');
        } else {
          log('WARNING', '‚ö†Ô∏è Aucune image valide trouv√©e');
        }
      } else {
        log('WARNING', '‚ö†Ô∏è Structure legacy d√©tect√©e (pas adminProduct.colorVariations)');
      }
      
      // V√©rification design application
      if (firstProduct.designApplication) {
        const designApp = firstProduct.designApplication;
        log('DEBUG', 'Design application:', {
          hasDesign: designApp.hasDesign,
          positioning: designApp.positioning,
          scale: designApp.scale
        });
      }
    }
    
    log('SUCCESS', '‚úÖ Structure API valid√©e');
    return true;
    
  } catch (error) {
    log('ERROR', `Erreur test structure API: ${error.message}`);
    return false;
  }
}

// Test 4: Health Metrics V2
async function testHealthMetrics() {
  log('INFO', 'üìä === TEST 4: HEALTH METRICS V2 ===');
  
  try {
    const response = await fetch(`${VENDOR_API_BASE}/products/health-report`, {
      method: 'GET',
      headers: getRequestHeaders(true)
    });
    
    if (!response.ok) {
      if (response.status === 401) {
        log('WARNING', 'Endpoint prot√©g√© - Skip test health metrics');
        return null;
      }
      
      log('WARNING', `Health report non disponible: ${response.status}`);
      return null;
    }
    
    const data = await response.json();
    
    if (data.success && data.healthReport) {
      const report = data.healthReport;
      
      log('SUCCESS', '‚úÖ Health report r√©cup√©r√©');
      log('DEBUG', 'Health metrics:', {
        totalProducts: report.totalProducts,
        healthyProducts: report.healthyProducts,
        overallHealthScore: report.overallHealthScore,
        architecture: report.architecture
      });
      
      // V√©rification score V2 (devrait √™tre 100%)
      if (report.overallHealthScore === 100) {
        log('SUCCESS', '‚úÖ Score de sant√© V2 optimal (100%)');
      } else {
        log('WARNING', `Score de sant√© non optimal: ${report.overallHealthScore}%`);
      }
      
      // V√©rification architecture
      if (report.architecture === 'v2_admin_preserved') {
        log('SUCCESS', '‚úÖ Architecture V2 confirm√©e dans health report');
      }
      
      return true;
    }
    
    log('WARNING', 'Health report structure inattendue');
    return false;
    
  } catch (error) {
    log('ERROR', `Erreur test health metrics: ${error.message}`);
    return false;
  }
}

// Test principal
async function runV2IntegrationTests() {
  console.log(`\n${colors.cyan}üß™ === TESTS INT√âGRATION V2 ARCHITECTURE ADMIN PR√âSERV√âE ===${colors.reset}\n`);
  
  const results = {
    healthCheck: await testHealthCheck(),
    authentication: await testAuthentication(),
    apiStructure: await testApiV2Structure(),
    healthMetrics: await testHealthMetrics()
  };
  
  console.log(`\n${colors.blue}üìä === R√âSULTATS DES TESTS ===${colors.reset}\n`);
  
  Object.entries(results).forEach(([test, result]) => {
    const status = result === true ? `${colors.green}‚úÖ PASS` : 
                   result === false ? `${colors.red}‚ùå FAIL` : 
                   `${colors.yellow}‚ö†Ô∏è SKIP`;
    console.log(`${status}${colors.reset} ${test}`);
  });
  
  const passCount = Object.values(results).filter(r => r === true).length;
  const totalCount = Object.values(results).filter(r => r !== null).length;
  
  console.log(`\n${colors.magenta}üéØ Score: ${passCount}/${totalCount} tests r√©ussis${colors.reset}\n`);
  
  if (passCount === totalCount && totalCount > 0) {
    console.log(`${colors.green}üéâ INT√âGRATION V2 VALID√âE AVEC SUCC√àS !${colors.reset}\n`);
    process.exit(0);
  } else {
    console.log(`${colors.yellow}‚ö†Ô∏è Des tests ont √©chou√© ou ont √©t√© ignor√©s${colors.reset}\n`);
    process.exit(1);
  }
}

// Ex√©cution si script appel√© directement
if (require.main === module) {
  runV2IntegrationTests().catch(error => {
    log('ERROR', `Erreur critique: ${error.message}`);
    process.exit(1);
  });
}

module.exports = {
  runV2IntegrationTests,
  testHealthCheck,
  testAuthentication,
  testApiV2Structure,
  testHealthMetrics
}; 